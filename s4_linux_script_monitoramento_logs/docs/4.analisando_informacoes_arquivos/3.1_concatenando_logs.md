# Concatenando Logs

Nós criamos um arquivo que traz dados estatísticos sobre nossos logs e temos vários arquivos de logs criados com o final .unico.

Quando realizamos a análise do conteúdo de cada um desses arquivos, torna-se complicado abrir um arquivo e depois outro. Portanto, é mais interessante centralizar todas essas informações em um único arquivo para facilitar a análise.
Criando uma pasta com mkdir

No terminal, vamos abrir o script monitoramento-logs.sh. Como o arquivo final trará logs processados, podemos mantê-lo em uma pasta separada para uma melhor organização.

Abaixo de LOG_DIR, vamos criar uma variável para armazenar o caminho desse novo diretório. A variável terá o nome ARQUIVO_DIR, com letras maiúsculas. Atribuiremos o valor ../myapp/logs-processados, entre aspas duplas:

#!/bin/bash

LOG_DIR="../myapp/logs"
ARQUIVO_DIR="../myapp/logs-processados"

#...

    Note que algumas variáveis são nomeadas em minúsculo e outras em maiúsculo. As escritas em maiúsculo armazenam informações que são como constantes, ou seja, dados que não mudam ao longo do tempo. Já as variáveis cujo valor pode mudar são escritas em minúsculo. Essa é uma convenção comum na programação.

A pasta "logs-processados" ainda não existe, mas podemos criá-la diretamente no script, usando o comando mkdir. Utilizaremos a opção -p para criar todos os diretórios-pais necessários. Caso o diretório já exista, a flag -p impedirá que ocorra algum erro ao tentar criá-lo novamente. Após o -p, chamamos a variável $ARQUIVO_DIR:

#!/bin/bash

LOG_DIR="../myapp/logs"
ARQUIVO_DIR="../myapp/logs-processados"

mkdir -p $ARQUIVO_DIR

#...

Concatenando arquivos de logs

Com a pasta criada, podemos concatenar todos os arquivos de log. Faremos isso no final do código, abaixo dos comandos echo, mas ainda dentro do laço de repetição.

O comando cat exibe o conteúdo de um arquivo no terminal, mas podemos combiná-lo com operadores de redirecionamento para direcionar a saída para um arquivo.

Vamos digitar cat seguido de ${arquivo}.unico. Assim, cada iteração do laço concatenará os arquivos. Até agora, o comando está assim:

cat "${arquivo}.unico"

Utilizaremos o operador >> para evitar a sobrescrita e, depois, especificaremos o caminho, que começará com ${ARQUIVO_DIR}. Após inserir uma barra, indicaremos o nome do arquivo que queremos utilizar, no caso, logs_combinados_DATA:

cat "${arquivo}.unico" >> "${ARQUIVO_DIR}/logs_combinados_DATA"

A ideia é que, no lugar de "DATA", apareça a data atual. Como podemos fazer isso? Antes de aprender um novo comando, vamos salvar nosso script e sair do editor.
Extraindo a data atual

Para extrair a data atual, usamos o comando date:

date

Ao executar date no terminal, o sistema exibe informações sobre a data atual: o dia da semana, o mês, o número do dia, horas, minutos, segundos, fuso horário e o ano.

Podemos formatar a data para extrair apenas os dados relevantes para nós. Por exemplo, a opção +%F retorna a data no formato ano-mês-dia, ideal para o nome do arquivo:

date +%F

Portanto, vamos usar esse comando no script monitoramento-logs.sh. Após abri-lo novamente, substituiremos a palavra "DATA" por $(date +%F):

# ...

    echo "Arquivo: $nome_arquivo" >> log_stats.txt
    echo "Número de linhas: $num_linhas" >> log_stats.txt
    echo "Número de palavras: $num_palavras" >> log_stats.txt
    echo "--------------------------" >> log_stats.txt

    cat "${arquivo}.unico" >> "${ARQUIVO_DIR}/logs_combinados_$(date +%F)"
done

Após salvar o script e sair do editor, vamos executá-lo com ./monitoramento-logs.sh. Em seguida, vamos até o diretório "myapp/logs-processados":

cd myapp/logs-processados

Ao listar os arquivos com ls, notaremos que o arquivo de logs combinados com a data atual foi criado. Podemos visualizar o conteúdo com o comando cat e teremos as informações de todos os arquivos de log em um único arquivo.

Na sequência, continuaremos realizando mais alterações no script.