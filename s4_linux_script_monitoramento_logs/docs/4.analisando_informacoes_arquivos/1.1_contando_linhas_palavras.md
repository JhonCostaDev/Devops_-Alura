# Contando linhas e palavras

Nós já adicionamos no nosso script de processamento de logs várias etapas que realizam esse processamento, criando alguns arquivos com os logs relevantes para nós, como os logs de erro e de dados sensíveis.

Agora, com aquele arquivo final que termina com unico, podemos extrair algumas informações quantitativas para realizar uma análise mais básica a respeito dos nossos logs.

Vamos extrair alguns valores, como a quantidade de linhas e a quantidade de palavras de cada um desses arquivos, para ter uma noção do volume de dados.

Ao longo do tempo, podemos armazenar esses dados e, se houver um aumento repentino em algum desses números, isso pode indicar que estamos enfrentando mais problemas na nossa aplicação, e precisamos observar mais de perto o que está acontecendo.

Vamos entender como podemos extrair cada um desses valores.
Contando linhas com wc

Com o terminal aberto, vamos abrir a pasta dos nossos logs com o comando:

cd myapp/logs

Agora, utilizaremos um comando do Linux que serve para realizar essa contagem de valores dentro de arquivos. Esse comando é o wc, que é uma abreviação para word count (contagem de palavras).

Esse comando oferece uma série de opções para indicar qual tipo de valor queremos, como quantidade de linhas, de palavras, de caracteres, o tamanho em bytes, entre outras. Vamos explorar algumas delas.

Já digitamos o wc e vamos extrair a quantidade de linhas com a opção -l. Em seguida, informamos o nome de um desses arquivos que termina com .unico:

wc -l myapp-backend.log.unico

O retorno será:

    18 myapp-backend.log.unico

Assim, sabemos que existem 18 linhas nesse arquivo, além do nome do arquivo informado. Esse valor pode indicar a quantidade de entradas de logs processadas, como erros e dados sensíveis.
Contando palavras com wc

Vamos digitar novamente o comando wc, agora com a opção -w, que conta a quantidade de palavras. Esse valor pode ajudar a verificar a quantidade total de informações nos nossos logs:

wc -w myapp-backend.log.unico

O retorno será:

    153 myapp-backend.log.unico

Nesse arquivo, temos 153 palavras. Desse modo, podemos utilizar esses comandos no nosso script para extrair esses valores e armazená-los para futuras análises temporais dos nossos logs.

Porém, essa saída não traz apenas o número, mas também o nome do arquivo. Queremos somente o valor numérico. Para extrair apenas esse número, vamos digitar:

wc -w < myapp-backend.log.unico

O operador < redireciona o conteúdo do arquivo como entrada para o comando. Note que esses operadores de redirecionamento sempre apontam para onde queremos enviar a saída de algum arquivo. Ao executar, ele traz como saída somente o valor desejado, sem o nome do arquivo:

    153

Vamos copiar esse comando e adicioná-lo ao nosso script.
Incrementando o script de monitoramento

Vamos até a pasta "script-linux/" e abrir o script monitoramento-logs.sh no Vim, mais uma vez. Após habilitar a edição com a tecla "I", adicionaremos o comando ao final do código, ainda dentro do laço de repetição. Em vez do myapp-backend.log.unico, usaremos a variável:

#!/bin/bash

LOG_DIR="../myapp/logs"

echo "Verificando logs no diretorio $LOG_DIR"

find $LOG_DIR -name "*.log" -print0 | while IFS= read -r -d '' arquivo; do
    grep "ERROR" "$arquivo" > "${arquivo}.filtrado"
    grep "SENSITIVE_DATA" "$arquivo" >> "${arquivo}.filtrado"

    sed -i 's/User password is .*/User password is REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User password reset request with token .*/User password reset request with token REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/API key leaked: .*/API key leaked: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User credit card last four digits: .*/User credit card last four digits: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User session initiated with token: .*/User session initiated with token: REDACTED/g' "${arquivo}.filtrado"

    sort "${arquivo}.filtrado" -o "${arquivo}.filtrado"

    uniq "${arquivo}.filtrado" > "${arquivo}.unico"

    wc -w < "${arquivo}.unico"
done

Logo abaixo, vamos adicionar o comando para contar as linhas também, com a opção -l:

#!/bin/bash

LOG_DIR="../myapp/logs"

echo "Verificando logs no diretorio $LOG_DIR"

find $LOG_DIR -name "*.log" -print0 | while IFS= read -r -d '' arquivo; do
    grep "ERROR" "$arquivo" > "${arquivo}.filtrado"
    grep "SENSITIVE_DATA" "$arquivo" >> "${arquivo}.filtrado"

    sed -i 's/User password is .*/User password is REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User password reset request with token .*/User password reset request with token REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/API key leaked: .*/API key leaked: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User credit card last four digits: .*/User credit card last four digits: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User session initiated with token: .*/User session initiated with token: REDACTED/g' "${arquivo}.filtrado"

    sort "${arquivo}.filtrado" -o "${arquivo}.filtrado"

    uniq "${arquivo}.filtrado" > "${arquivo}.unico"

    wc -w < "${arquivo}.unico"
    wc -l < "${arquivo}.unico"
done

Agora que temos os comandos de contagem de palavras e de linhas, é interessante armazenar as saídas em variáveis. Portanto, antes de cada comando, criaremos uma variável. Na linha onde temos a opção -w, usaremos uma variável chamada num_palavras. Na linha com a opção -l, utilizaremos num_linhas.

Para armazenar a saída de um comando do Linux em uma variável, é preciso inserir o sinal de dólar no início e colocar o comando entre parênteses. Logo, as linhas ficarão assim:

num_palavras=$(wc -w < "${arquivo}.unico")
num_linhas=$(wc -l < "${arquivo}.unico")

Assim, conseguimos armazenar esses valores dentro de variáveis e, na sequência, vamos entender como utilizá-las e salvá-las em um arquivo.Nós já adicionamos no nosso script de processamento de logs várias etapas que realizam esse processamento, criando alguns arquivos com os logs relevantes para nós, como os logs de erro e de dados sensíveis.

Agora, com aquele arquivo final que termina com unico, podemos extrair algumas informações quantitativas para realizar uma análise mais básica a respeito dos nossos logs.

Vamos extrair alguns valores, como a quantidade de linhas e a quantidade de palavras de cada um desses arquivos, para ter uma noção do volume de dados.

Ao longo do tempo, podemos armazenar esses dados e, se houver um aumento repentino em algum desses números, isso pode indicar que estamos enfrentando mais problemas na nossa aplicação, e precisamos observar mais de perto o que está acontecendo.

Vamos entender como podemos extrair cada um desses valores.
Contando linhas com wc

Com o terminal aberto, vamos abrir a pasta dos nossos logs com o comando:

cd myapp/logs

Agora, utilizaremos um comando do Linux que serve para realizar essa contagem de valores dentro de arquivos. Esse comando é o wc, que é uma abreviação para word count (contagem de palavras).

Esse comando oferece uma série de opções para indicar qual tipo de valor queremos, como quantidade de linhas, de palavras, de caracteres, o tamanho em bytes, entre outras. Vamos explorar algumas delas.

Já digitamos o wc e vamos extrair a quantidade de linhas com a opção -l. Em seguida, informamos o nome de um desses arquivos que termina com .unico:

wc -l myapp-backend.log.unico

O retorno será:

    18 myapp-backend.log.unico

Assim, sabemos que existem 18 linhas nesse arquivo, além do nome do arquivo informado. Esse valor pode indicar a quantidade de entradas de logs processadas, como erros e dados sensíveis.
Contando palavras com wc

Vamos digitar novamente o comando wc, agora com a opção -w, que conta a quantidade de palavras. Esse valor pode ajudar a verificar a quantidade total de informações nos nossos logs:

wc -w myapp-backend.log.unico

O retorno será:

    153 myapp-backend.log.unico

Nesse arquivo, temos 153 palavras. Desse modo, podemos utilizar esses comandos no nosso script para extrair esses valores e armazená-los para futuras análises temporais dos nossos logs.

Porém, essa saída não traz apenas o número, mas também o nome do arquivo. Queremos somente o valor numérico. Para extrair apenas esse número, vamos digitar:

wc -w < myapp-backend.log.unico

O operador < redireciona o conteúdo do arquivo como entrada para o comando. Note que esses operadores de redirecionamento sempre apontam para onde queremos enviar a saída de algum arquivo. Ao executar, ele traz como saída somente o valor desejado, sem o nome do arquivo:

    153

Vamos copiar esse comando e adicioná-lo ao nosso script.
Incrementando o script de monitoramento

Vamos até a pasta "script-linux/" e abrir o script monitoramento-logs.sh no Vim, mais uma vez. Após habilitar a edição com a tecla "I", adicionaremos o comando ao final do código, ainda dentro do laço de repetição. Em vez do myapp-backend.log.unico, usaremos a variável:

#!/bin/bash

LOG_DIR="../myapp/logs"

echo "Verificando logs no diretorio $LOG_DIR"

find $LOG_DIR -name "*.log" -print0 | while IFS= read -r -d '' arquivo; do
    grep "ERROR" "$arquivo" > "${arquivo}.filtrado"
    grep "SENSITIVE_DATA" "$arquivo" >> "${arquivo}.filtrado"

    sed -i 's/User password is .*/User password is REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User password reset request with token .*/User password reset request with token REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/API key leaked: .*/API key leaked: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User credit card last four digits: .*/User credit card last four digits: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User session initiated with token: .*/User session initiated with token: REDACTED/g' "${arquivo}.filtrado"

    sort "${arquivo}.filtrado" -o "${arquivo}.filtrado"

    uniq "${arquivo}.filtrado" > "${arquivo}.unico"

    wc -w < "${arquivo}.unico"
done

Logo abaixo, vamos adicionar o comando para contar as linhas também, com a opção -l:

#!/bin/bash

LOG_DIR="../myapp/logs"

echo "Verificando logs no diretorio $LOG_DIR"

find $LOG_DIR -name "*.log" -print0 | while IFS= read -r -d '' arquivo; do
    grep "ERROR" "$arquivo" > "${arquivo}.filtrado"
    grep "SENSITIVE_DATA" "$arquivo" >> "${arquivo}.filtrado"

    sed -i 's/User password is .*/User password is REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User password reset request with token .*/User password reset request with token REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/API key leaked: .*/API key leaked: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User credit card last four digits: .*/User credit card last four digits: REDACTED/g' "${arquivo}.filtrado"
    sed -i 's/User session initiated with token: .*/User session initiated with token: REDACTED/g' "${arquivo}.filtrado"

    sort "${arquivo}.filtrado" -o "${arquivo}.filtrado"

    uniq "${arquivo}.filtrado" > "${arquivo}.unico"

    wc -w < "${arquivo}.unico"
    wc -l < "${arquivo}.unico"
done

Agora que temos os comandos de contagem de palavras e de linhas, é interessante armazenar as saídas em variáveis. Portanto, antes de cada comando, criaremos uma variável. Na linha onde temos a opção -w, usaremos uma variável chamada num_palavras. Na linha com a opção -l, utilizaremos num_linhas.

Para armazenar a saída de um comando do Linux em uma variável, é preciso inserir o sinal de dólar no início e colocar o comando entre parênteses. Logo, as linhas ficarão assim:

num_palavras=$(wc -w < "${arquivo}.unico")
num_linhas=$(wc -l < "${arquivo}.unico")

Assim, conseguimos armazenar esses valores dentro de variáveis e, na sequência, vamos entender como utilizá-las e salvá-las em um arquivo.

## Question - Análise de logs no Adopet


No site de adoção de animais Adopet, você é responsável por monitorar os logs do sistema para garantir que tudo funcione corretamente. Após processar os logs, você precisa analisar o volume de dados para identificar possíveis anomalias, como um aumento repentino no número de erros.

Como você pode usar o comando wc para contar apenas o número de palavras no arquivo adopet-logs.log.unico sem que o nome do arquivo apareça na saída?